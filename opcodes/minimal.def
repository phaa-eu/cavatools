#  Opcode	Assembler	Attributes		     Instruction Format				Register Fields				C++ Semantics

# Special instructions
   c.ebreak     -               C,ex                         "100 1      00000       00000 10"          -,-,-,-                                 "ebreak()"
   ebreak       -               I,ex            "000000000001      00000 000   00000 11100 11"          -,-,-,-                                 "ebreak()"
   ecall	-		<,I,ex,>	"000000000000      00000 000   00000 11100 11"		-,-,-,-					"riscv_syscall()"

   csrrw	d,E,s		<,I,sr,>	"{11:0}            ..... 001   ..... 11100 11"		l[11:7],l[19:15],-,-			"wrd(csr_func(imm,       [&](uint64_t old) { return        r1;                  } ))"
   csrrs	d,E,s		<,I,sr,>	"{11:0}            ..... 010   ..... 11100 11"		l[11:7],l[19:15],-,-			"wrd(csr_func(imm,       [&](uint64_t old) { return old |  r1;                  } ))"
   csrrc	d,E,s		<,I,sr,>	"{11:0}            ..... 011   ..... 11100 11"		l[11:7],l[19:15],-,-			"wrd(csr_func(imm,       [&](uint64_t old) { return old & ~r1;                  } ))"
   csrrwi	d,E,Z		<,I,sr,>	"{11:0}          {16:12} 101   ..... 11100 11"		l[11:7],-,-,-				"wrd(csr_func(imm&0xFFF, [&](uint64_t old) { return                  (imm>>12); } ))"
   csrrsi	d,E,Z		<,I,sr,>	"{11:0}          {16:12} 110   ..... 11100 11"		l[11:7],-,-,-				"wrd(csr_func(imm&0xFFF, [&](uint64_t old) { return old |            (imm>>12); } ))"
   csrrci	d,E,Z		<,I,sr,>	"{11:0}          {16:12} 111   ..... 11100 11"		l[11:7],-,-,-				"wrd(csr_func(imm&0xFFF, [&](uint64_t old) { return old & ~(uint64_t)(imm>>12); } ))"
   
# Branch instructions
   c.j		-		C,uj,>			     "101 {-11|4|9:8|10|6|7|3:1|5} 01"		-,-,-,-					"jump(pc+imm)"
   c.beqz	rs1		C,cj,>			     "110 {-8|4:3} ... {7:6|2:1|5} 01"		-,l[9:7]+8,-,-				"branch(r1==0, pc+imm, pc+2)"
   c.bnez	rs1		C,cj,>			     "111 {-8|4:3} ... {7:6|2:1|5} 01"		-,l[9:7]+8,-,-				"branch(r1!=0, pc+imm, pc+2)"
   c.ret	rs1		C,uj,>			     "100 0      00001       00000 10"		-,1,-,-					"reg_jump(r1)"
   c.jr		rs1		C,uj,>			     "100 0      .....       00000 10"		-,l[11:7],-,-				"reg_jump(r1)"
   c.jalr	rs1		C,uj,>			     "100 1      .....       00000 10"		1,l[11:7],-,-				"{ long npc=r1; wrd(pc+2); jump(npc); }"
   
   j		a		I,uj,>		"{-20|10:1|11|19:12}           00000 11011 11"		l[11:7],-				"           jump(pc+imm)"
   jal		d,a		I,uj,>		"{-20|10:1|11|19:12}           ..... 11011 11"		l[11:7],-				"wrd(pc+4); jump(pc+imm)"
   ret		d,s		I,uj,>		"{-11:0}           ..... 000   00000 11001 11"		-,l[19:15],-,-				"reg_jump((r1+imm)&~1L)"
   jalr		d,s		I,uj,>		"{-11:0}           ..... 000   ..... 11001 11"		l[11:7],l[19:15],-,-			"{ long npc=(r1+imm)&~1L; wrd(pc+4); reg_jump(npc); }"

   beq		s,t,p		I,cj,>		"{-12|10:5}  ..... ..... 000 {4:1|11} 1100011"		-,l[19:15],l[24:20],-			"branch( int64_t(r1)== int64_t(r2), pc+imm, pc+4)"
   bne		s,t,p		I,cj,>		"{-12|10:5}  ..... ..... 001 {4:1|11} 1100011"		-,l[19:15],l[24:20],-			"branch( int64_t(r1)!= int64_t(r2), pc+imm, pc+4)"
   blt		s,t,p		I,cj,>		"{-12|10:5}  ..... ..... 100 {4:1|11} 1100011"		-,l[19:15],l[24:20],-			"branch( int64_t(r1)<  int64_t(r2), pc+imm, pc+4)"
   bge		s,t,p		I,cj,>		"{-12|10:5}  ..... ..... 101 {4:1|11} 1100011"		-,l[19:15],l[24:20],-			"branch( int64_t(r1)>= int64_t(r2), pc+imm, pc+4)"
   bltu		s,t,p		I,cj,>		"{-12|10:5}  ..... ..... 110 {4:1|11} 1100011"		-,l[19:15],l[24:20],-			"branch(uint64_t(r1)< uint64_t(r2), pc+imm, pc+4)"
   bgeu		s,t,p		I,cj,>		"{-12|10:5}  ..... ..... 111 {4:1|11} 1100011"		-,l[19:15],l[24:20],-			"branch(uint64_t(r1)>=uint64_t(r2), pc+imm, pc+4)"

# AMO cannot use Spike
   lr.w		d,0(s)		A,amo,ld	"00010 {1:0} 00000 ..... 010   ..... 01011 11"		w[11:7],l[19:15],-,-			"wrd(LOAD(int32_t, r1))"
   sc.w		d,t,0(s)	A,amo,st,>	"00011 {1:0} ..... ..... 010   ..... 01011 11"		l[11:7],l[19:15],w[24:20],-		"STORE(int32_t, r1, r2); wrd(0)"
   amoswap.w	d,t,0(s)	A,amo,st,>	"00001 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd(amo_int32(r1, [&](int32_t lhs) { return       r2; }, ap))"
   amoadd.w	d,t,0(s)	A,amo,st,>	"00000 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd(amo_int32(r1, [&](int32_t lhs) { return lhs + r2; }, ap))"
   amoxor.w	d,t,0(s)	A,amo,st,>	"00100 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd(amo_int32(r1, [&](int32_t lhs) { return lhs ^ r2; }, ap))"
   amoand.w	d,t,0(s)	A,amo,st,>	"01100 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd(amo_int32(r1, [&](int32_t lhs) { return lhs & r2; }, ap))"
   amoor.w	d,t,0(s)	A,amo,st,>	"01000 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd(amo_int32(r1, [&](int32_t lhs) { return lhs | r2; }, ap))"
   amomin.w	d,t,0(s)	A,amo,st,>	"10000 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd(amo_int32(r1, [&](int32_t lhs) { return std::min(lhs,  int32_t(r2)); }, ap))"
   amomax.w	d,t,0(s)	A,amo,st,>	"10100 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd(amo_int32(r1, [&](int32_t lhs) { return std::max(lhs,  int32_t(r2)); }, ap))"
   amominu.w	d,t,0(s)	A,amo,st,>	"11000 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd((uint32_t)amo_int32(r1, [&](uint32_t lhs) { return std::min(lhs, uint32_t(r2)); }, ap))"
   amomaxu.w	d,t,0(s)	A,amo,st,>	"11100 {1:0} ..... ..... 010   ..... 01011 11"		w[11:7],l[19:15],w[24:20],-		"wrd((uint32_t)amo_int32(r1, [&](uint32_t lhs) { return std::max(lhs, uint32_t(r2)); }, ap))"

   lr.d		d,0(s)		A,amo,ld	"00010 {1:0} 00000 ..... 011   ..... 01011 11"		l[11:7],l[19:15],-,-			"wrd(LOAD(int64_t,  r1))"
   sc.d		d,t,0(s)	A,amo,st,>	"00011 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"STORE(int64_t, r1, r2); wrd(0)"
   amoswap.d	d,t,0(s)	A,amo,st,>	"00001 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](int64_t lhs) { return       r2; }, ap))"
   amoadd.d	d,t,0(s)	A,amo,st,>	"00000 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](int64_t lhs) { return lhs + r2; }, ap))"
   amoxor.d	d,t,0(s)	A,amo,st,>	"00100 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](int64_t lhs) { return lhs ^ r2; }, ap))"
   amoand.d	d,t,0(s)	A,amo,st,>	"01100 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](int64_t lhs) { return lhs & r2; }, ap))"
   amoor.d	d,t,0(s)	A,amo,st,>	"01000 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](int64_t lhs) { return lhs | r2; }, ap))"
   amomin.d	d,t,0(s)	A,amo,st,>	"10000 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](int64_t  lhs) { return std::min(lhs,  int64_t(r2)); }, ap))"
   amomax.d	d,t,0(s)	A,amo,st,>	"10100 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](int64_t  lhs) { return std::max(lhs,  int64_t(r2)); }, ap))"
   amominu.d	d,t,0(s)	A,amo,st,>	"11000 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](uint64_t lhs) { return std::min(lhs, uint64_t(r2)); }, ap))"
   amomaxu.d	d,t,0(s)	A,amo,st,>	"11100 {1:0} ..... ..... 011   ..... 01011 11"		l[11:7],l[19:15],l[24:20],-		"wrd(amo_int64(r1, [&](uint32_t lhs) { return std::max(lhs, uint32_t(r2)); }, ap))"

# Internal instructions to emulate Compare-And-Swap
   cas.w	d,t,0(s),r	A,amo,st,>	"..... 11    ..... ..... 111   ..... 11111 11"		w[11:7],l[19:15],w[24:20],w[31:27]	"wrd(cas<int32_t>(i, ap))"
   cas.d	d,t,0(s),r	A,amo,st,>	"..... 11    ..... ..... 111   ..... 11111 11"		l[11:7],l[19:15],l[24:20],l[31:27]	"wrd(cas<int64_t>(i, ap))"

